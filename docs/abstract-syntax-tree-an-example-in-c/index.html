<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=748;" />
  <!-- favicon stuff -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
  <!--link rel="mask-icon" href="/safari-pinned-tab.svg?v=1"> <!-- color="#5bbad5">-->
  <link rel="shortcut icon" href="/favicon.ico?v=1">
  <!--meta name="theme-color" content="#ffffff"-->

  <meta name="dcterms.date" content="2022-06-20" />
  <title>Abstract Syntax Tree: an Example in C</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.dt { text-decoration: underline; } /* DataType */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
  <span id="home-menu"><a title="Home" href="/">☰</a></span>


  <h1>Abstract Syntax Tree<br/><small><small>an Example in C</small></small></h1>

<center style="margin: 25.46px;" ><em>With pretty-printing and code generation</em></center>

<center style="margin: 25.46px;" >Vladimir Keleshev • 2022-06-20</center>

<header id="title-block-header">
</header>
<p>In <a href="/one-pass-compiler-primer">a previous blog post</a>, we looked at a simple one-pass compiler written in C. Now, let’s look at how we can design an <em>abstract syntax tree</em> and work with it.</p>
<p>An abstract syntax tree (or an AST) is a tree-shaped representation of source code that is convenient for a compiler to operate. A compiler might represent an expression like <code>4 + 2 * 10 + 3 * (5 + 1)</code> using a tree structure like this:</p>
<figure>
<img src="ast.svg" alt="Figure 1. Abstract syntax tree example" /><figcaption aria-hidden="true">Figure 1. Abstract syntax tree example</figcaption>
</figure>
<p>In object-oriented languages, it is common to represent an AST using a hierarchy of data classes, one subclass per tree node. In functional languages, it is common to use a variant data type, in other words, a <em>tagged union</em>, with one variant per tree node. C does not have good support for either of those language features. However, we can manually implement a tagged union. Here’s how we can do that.</p>
<h2 id="tagged-union">Tagged union</h2>
<p>We define our AST type as a <code>struct</code> holding two members,</p>
<ul>
<li>an <code>enum</code> called <code>tag</code>, enumerating each node type, and</li>
<li>a <code>union</code> called <code>data</code>, consisting of data members for each tag type.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> AST AST<span class="op">;</span> <span class="co">// Forward reference</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> AST <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    AST_NUMBER<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    AST_ADD<span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    AST_MUL<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> tag<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AST_NUMBER <span class="op">{</span> <span class="dt">int</span> number<span class="op">;</span> <span class="op">}</span> AST_NUMBER<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AST_ADD <span class="op">{</span> AST <span class="op">*</span>left<span class="op">;</span> AST <span class="op">*</span>right<span class="op">;</span> <span class="op">}</span> AST_ADD<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AST_MUL <span class="op">{</span> AST <span class="op">*</span>left<span class="op">;</span> AST <span class="op">*</span>right<span class="op">;</span> <span class="op">}</span> AST_MUL<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> data<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>We want data members to reference other AST nodes, and since C does not allow recursive type definitions, we make a forward reference by defining <code>AST</code> as <code>struct AST</code>. We can do this because the namespace of <code>struct</code>s and the namespace of types are separate in C.</p>
<p>In this tagged union implementation, an identifier like <code>AST_NUMBER</code> is mentioned three times:</p>
<ul>
<li>first, as an <code>enum</code> member,</li>
<li>second, as the name of the <code>struct</code>, and</li>
<li>third, as the name of the data member.</li>
</ul>
<p>C does not have a built-in concept of a tagged union, so there are many ways to implement it. You could name the <code>enum</code> and the <code>union</code> types, for example, and define them separately. Or, you could use an anonymous <code>union</code> or <code>struct</code> (standard since C11). You can decide not to wrap a single member into a <code>struct</code>, like in the case of <code>int number</code>. However, the design chosen here has some advantages that we will discuss further.</p>
<p>With <code>AST</code> defined this way, our original example (<code>4 + 2 * 10 + 3 * (5 + 1)</code>) has the following layout in memory.</p>
<figure>
<img src="ast-memory-layout.svg" alt="Figure 2. Box and pointer diagram" /><figcaption aria-hidden="true">Figure 2. Box and pointer diagram</figcaption>
</figure>
<p>To heap-allocate an AST node we can use a function like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>AST <span class="op">*</span>ast_new<span class="op">(</span>AST ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  AST <span class="op">*</span>ptr <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>AST<span class="op">));</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>ptr<span class="op">)</span> <span class="op">*</span>ptr <span class="op">=</span> ast<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ptr<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>   </span></code></pre></div>
<p>Now, we can represent an expression <code>5 + 1</code> using the following code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  AST <span class="op">*</span>term_ <span class="op">=</span> ast_new<span class="op">((</span>AST<span class="op">){</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    AST_ADD<span class="op">,</span> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>AST_ADD<span class="op">=(</span><span class="kw">struct</span> AST_ADD<span class="op">){</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        ast_new<span class="op">((</span>AST<span class="op">){</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>          AST_NUMBER<span class="op">,</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">{.</span>AST_NUMBER<span class="op">=(</span><span class="kw">struct</span> AST_NUMBER<span class="op">){</span><span class="dv">5</span><span class="op">}}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}),</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        ast_new<span class="op">((</span>AST<span class="op">){</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>          AST_NUMBER<span class="op">,</span> </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">{.</span>AST_NUMBER<span class="op">=(</span><span class="kw">struct</span> AST_NUMBER<span class="op">){</span><span class="dv">1</span><span class="op">}}}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">),</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">});</span></span></code></pre></div>
<p>This is just C being C, isn’t it? There is no local type inference, so we must cast each <code>struct</code> to the correct type. We also have to use designated initializers (like <code>.AST_ADD=</code>) because that’s the only way to initialize an arbitrary union in a single expression.</p>
<p>To some extent, we even asked for it when we wrapped the harmless <code>int number</code> into a <code>struct AST_NUMBER</code>.</p>
<p>However, C being C, we can create a vararg macro that can reduce this boilerplate:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define AST_NEW(tag, ...) \</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">  ast_new((AST){tag, {.tag=(struct tag){__VA_ARGS__}}})</span></span></code></pre></div>
<p>This macro ties together the matching identifiers from the <code>enum</code>, the <code>struct</code>, and the data members. With this, we can initialize <code>4 + 2 * 10 + 3 * (5 + 1)</code> as follows.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  AST <span class="op">*</span>term <span class="op">=</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    AST_NEW<span class="op">(</span>AST_ADD<span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>      AST_NEW<span class="op">(</span>AST_NUMBER<span class="op">,</span> <span class="dv">4</span><span class="op">),</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>      AST_NEW<span class="op">(</span>AST_ADD<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        AST_NEW<span class="op">(</span>AST_MUL<span class="op">,</span> </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>          AST_NEW<span class="op">(</span>AST_NUMBER<span class="op">,</span> <span class="dv">2</span><span class="op">),</span> </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>          AST_NEW<span class="op">(</span>AST_NUMBER<span class="op">,</span> <span class="dv">10</span><span class="op">),</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">),</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        AST_NEW<span class="op">(</span>AST_MUL<span class="op">,</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>          AST_NEW<span class="op">(</span>AST_NUMBER<span class="op">,</span> <span class="dv">3</span><span class="op">),</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>          AST_NEW<span class="op">(</span>AST_ADD<span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            AST_NEW<span class="op">(</span>AST_NUMBER<span class="op">,</span> <span class="dv">5</span><span class="op">),</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            AST_NEW<span class="op">(</span>AST_NUMBER<span class="op">,</span> <span class="dv">1</span><span class="op">),</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">),</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">),</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>      <span class="op">),</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span></code></pre></div>
<p>We could even shorten <code>AST_NEW(AST_ADD, …)</code> to <code>AST(ADD, …)</code> with token concatenation (<code>##</code> macro operator), but that is beyond my taste in C programming.</p>
<p>Now, how do we operate with this AST…</p>
<h2 id="pretty-printing-example">Pretty-printing example</h2>
<p>A common way to operate on a tagged union is to use something like a <code>switch</code> statement, which switches over the tag value, where each case operates on the corresponding data value.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ast_print<span class="op">(</span>AST <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  AST ast <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>ast<span class="op">.</span>tag<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_NUMBER<span class="op">:</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_NUMBER data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_NUMBER<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> data<span class="op">.</span>number<span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_ADD<span class="op">:</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_ADD data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_ADD<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      ast_print<span class="op">(</span>data<span class="op">.</span>left<span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot; + &quot;</span><span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>      ast_print<span class="op">(</span>data<span class="op">.</span>right<span class="op">);</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_MUL<span class="op">:</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_MUL data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_MUL<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>      ast_print<span class="op">(</span>data<span class="op">.</span>left<span class="op">);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot; * &quot;</span><span class="op">);</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>      ast_print<span class="op">(</span>data<span class="op">.</span>right<span class="op">);</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A modern compiler like <code>gcc</code> or <code>clang</code> will detect that you are using an <code>enum</code> type in the switch statement and will warn if the switch is not exhaustive. Use the flag <code>-Wswitch</code> to ensure that, and <code>-Werror</code> to make it an error.</p>
<p>A common error is forgetting a <code>break</code> or a <code>return</code> at the end of each statement, thus triggering a fall-through that can lead to some hard-to-debug bugs. Use <code>-Wimplicit-fallthrough</code> to require an explicit annotation if you want the fall-through behaviour and warn otherwise. The exact annotation syntax varies with other flags, but usually, <code>__attribute__((fallthrough))</code> works.</p>
<p>With all these warnings enabled, the experience of using tagged unions in C is not that bad, huh? The one serious issue is that C will not stop you from accessing the wrong union member. For example, you can match on <code>AST_NUMBER</code>, but then query for <code>ast.data.AST_MUL.left</code>.</p>
<p>To somewhat counter that, I suggest the programming style where each case is immediately followed by binding the correct union member as <code>data</code>, like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_NUMBER<span class="op">:</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_NUMBER data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_NUMBER<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> data<span class="op">.</span>number<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Here, our matching naming pays off, I think. It makes it easy to code review that we are accessing the correct union data, and if we accidentally use the wrong union member down the line, it will scream at us something like <code>ast.data.AST_ADD</code>.</p>
<p>We could extract this pattern into a <code>CASE</code> macro, but this is also beyond me.</p>
<h2 id="deallocation-example">Deallocation example</h2>
<p>We’ve looked at how we can allocate AST nodes using <code>ast_new</code> function and <code>AST_NEW</code> macro. Let’s write deallocation function to match that. We will use a similar technique to our <code>ast_print</code> function.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ast_free<span class="op">(</span>AST <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  AST ast <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>ast<span class="op">.</span>tag<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_NUMBER<span class="op">:</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_NUMBER data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_NUMBER<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_ADD<span class="op">:</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_ADD data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_ADD<span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      ast_free<span class="op">(</span>data<span class="op">.</span>left<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      ast_free<span class="op">(</span>data<span class="op">.</span>right<span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_MUL<span class="op">:</span> <span class="op">{</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_MUL data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_MUL<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      ast_free<span class="op">(</span>data<span class="op">.</span>left<span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>      ast_free<span class="op">(</span>data<span class="op">.</span>right<span class="op">);</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  free<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>   </span></code></pre></div>
<h2 id="code-generation">Code generation</h2>
<p>Let’s make a simple code generator that emits x86-64 Intel assembly. Similar to what we did for the <a href="/one-pass-compiler-primer">one-pass compiler</a>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define emitf printf</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ast_emit<span class="op">(</span>AST <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  AST ast <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>ast<span class="op">.</span>tag<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_NUMBER<span class="op">:</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_NUMBER data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_NUMBER<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  mov rax, %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> data<span class="op">.</span>number<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_ADD<span class="op">:</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_ADD data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_ADD<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>      ast_emit<span class="op">(</span>data<span class="op">.</span>left<span class="op">);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  push rax</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      ast_emit<span class="op">(</span>data<span class="op">.</span>right<span class="op">);</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  pop rbx</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  add rax, rbx</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_MUL<span class="op">:</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_MUL data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_MUL<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>      ast_emit<span class="op">(</span>data<span class="op">.</span>left<span class="op">);</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  push rax</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>      ast_emit<span class="op">(</span>data<span class="op">.</span>right<span class="op">);</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  pop rbx</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  mul rbx</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code generator will be able to compile our expressions to snippets of assembly. However, to generate a complete program, we need an entry point. Let’s add that as a new node <code>AST_MAIN</code>, as well as the corresponding functions:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> AST <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    AST_MAIN<span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    …</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> tag<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AST_MAIN <span class="op">{</span> AST <span class="op">*</span>body<span class="op">;</span> <span class="op">}</span> AST_MAIN<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    …</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> data<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>…</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ast_emit<span class="op">(</span>AST <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> AST_MAIN<span class="op">:</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> AST_MAIN data <span class="op">=</span> ast<span class="op">.</span>data<span class="op">.</span>AST_MAIN<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;.global main</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;main:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// &quot;_main&quot; on macOS</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>      ast_emit<span class="op">(</span>data<span class="op">.</span>body<span class="op">);</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;  ret</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>      emitf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now, if we pass our example AST (<code>4 + 2 * 10 + 3 * (5 + 1)</code>) to <code>ast_emit</code>, we will get the following assembly code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode gnuassembler"><code class="sourceCode gnuassembler"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">.global</span> main</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">main:</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  mov rax<span class="op">,</span> <span class="dv">4</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  push rax</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  mov rax<span class="op">,</span> <span class="dv">2</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  push rax</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  mov rax<span class="op">,</span> <span class="dv">10</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  pop rbx</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  mul rbx</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  push rax</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  mov rax<span class="op">,</span> <span class="dv">3</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  push rax</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  mov rax<span class="op">,</span> <span class="dv">5</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  push rax</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  mov rax<span class="op">,</span> <span class="dv">1</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  pop rbx</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  add rax<span class="op">,</span> rbx</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  pop rbx</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  mul rbx</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  pop rbx</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  add rax<span class="op">,</span> rbx</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  pop rbx</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  add rax<span class="op">,</span> rbx</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>  ret</span></code></pre></div>
<p>Let’s use <code>gcc test.s -masm=intel -o test.exe</code> as the command to assemble and link it, and we get the expected output:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./test.exe </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="va">$?</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ex">42</span></span></code></pre></div>
<ol start="42" type="1">
<li>Which is the result of <code>4 + 2 * 10 + 3 * (5 + 1)</code>.</li>
</ol>
<p>Thank you for your attention. <a href="/" title="Home">☰</a></p>
<h2 id="newsletter">Newsletter</h2>
<blockquote>
<p>Subscribe to receive an occasional email from me about compilers, functional programming, or my book <a href="/compiling-to-assembly-from-scratch">Compiling to Assembly from Scratch</a>.</p>
<script async data-uid="8529ea38b4" src="https://motivated-writer-7421.ck.page/8529ea38b4/index.js"></script>
<p>Unsubscribe at any time.</p>
</blockquote>
<h2 id="bonus-ocaml-version">Bonus: OCaml version</h2>
<p>Are you still considering using C for writing a compiler? Consider again! Here’s the same example written in OCaml with complete type and memory safety:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ast = </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  | Main <span class="kw">of</span> ast </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  | Number <span class="kw">of</span> <span class="dt">int</span> </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  | Add <span class="kw">of</span> ast * ast</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  | Mul <span class="kw">of</span> ast * ast</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> emitf x = <span class="dt">Printf</span>.kprintf <span class="dt">print_endline</span> x</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> emit = <span class="kw">function</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  | Main body -&gt;</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;.global main&quot;</span>;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;main:&quot;</span>;</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>      emit body;</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  ret&quot;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  | Number n -&gt;</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  mov rax, %d&quot;</span> n</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  | Add (left, right) -&gt;</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>      emit left;</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  push rax&quot;</span>;</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>      emit right;</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  pop rbx&quot;</span>;</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  add rax, rbx&quot;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>  | Mul (left, right) -&gt;</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>      emit left;</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  push rax&quot;</span>;</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>      emit right;</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  pop rbx&quot;</span>;</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>      emitf <span class="st">&quot;  mul rbx&quot;</span></span></code></pre></div>
<h2 id="source-code"><a href="https://gist.github.com/keleshev/6efbf2fc521b2f0797decb19c6932ecc">Source code</a></h2>
<h2 id="bibtex">BibTeX</h2>
<p><small></p>
<pre><code>@misc{Keleshev:2022-1,
  title=&quot;Abstract Syntax Tree: an Example in C&quot;,
  author=&quot;Vladimir Keleshev&quot;,
  year=2022,
  howpublished=
    &quot;\url{https://keleshev.com/abstract-syntax-tree-an-example-in-c}&quot;,
}</code></pre>
<p></small></p>


  <hr class="fleuron" />
</body>
</html>
