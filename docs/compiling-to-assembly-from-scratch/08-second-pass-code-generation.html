<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=750;" />
  <!-- favicon stuff -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
  <!--link rel="mask-icon" href="/safari-pinned-tab.svg?v=1"> <!-- color="#5bbad5">-->
  <link rel="shortcut icon" href="/favicon.ico?v=1">
  <!--meta name="theme-color" content="#ffffff"-->

  <title>8. Second Pass: Code Generation • Compiling to Assembly from Scratch</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.dt { text-decoration: underline; } /* DataType */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>




<header>
<h1><small><small>Chapter 8</small></small><br/>Second Pass: Code Generation</h1>
<a href='./#table-of-contents'>Compiling to Assembly from Scratch</a>
<br/>by <a href='/'>Vladimir Keleshev</a>
</header>
<p> </p>
<p>The second and the last pass of our compiler is called the <em>emitter</em> or the <em>code generator</em>, since it generates the assembly code. It converts an AST of a program into assembly instrucitons. How do we organize that? We extend the <code>AST</code> interface with a new method called <code>emit</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> AST {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>()<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>It’s a cool method—you may say—it takes no parameters and returns nothing (or <code class="sourceCode javascript"><span class="kw">void</span></code>). So, what’s the use of it? First, it takes the implicit <code class="sourceCode javascript"><span class="kw">this</span></code> parameter, and with it all the instance variables of each node. Second, even though the signature return type is <code class="sourceCode javascript"><span class="kw">void</span></code>, when this method is called, it will emit assembly as a <em>side effect</em>. For that we will use an <code>emit</code> function (as opposed to a method). Using this function we can emit instructions like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">emit</span>(<span class="st">&quot;  add r1, r2, r3&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>More often, we will use template literals for string interpolation when emitting code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">emit</span>(<span class="vs">`  add r1, r2, #</span><span class="sc">${</span>x<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span></code></pre></div>
<p>This will emit <code>add r1, r2, #42</code>. How do we implement the <code>emit</code> function? We can define it so that it appends a line to an array, or writes a line to a file. But for now, let’s define it as follows, for simplicity:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> emit <span class="op">=</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span><span class="op">;</span></span></code></pre></div>
<p>That’s right, <code>emit</code> simply prints to the console’s standard output channel. This is good enough, for now. We can redirect standard output to a file, and then assemble it.</p>
<p>What about the <em>method</em> <code>emit</code>? First, we define this method on every AST node to satisfy the interface. A dummy implementation will suffice, for a start. Let’s use <code>Number</code> node as an example.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Number</span> <span class="kw">implements</span> AST {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">value</span><span class="op">:</span> number) {}</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() { <span class="cf">throw</span> <span class="bu">Error</span>(<span class="st">&quot;Not implemented yet&quot;</span>)<span class="op">;</span> }</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Next, we will modify each node to emit the correct assembly. For example, in case of <code>Number</code> it will eventually be as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">emit</span>() {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="vs">`  ldr r0, =</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">value</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This way, each AST node will be able to emit corresponding assembly. Nodes that have other nodes as instance variables will be able to call their <code>emit</code> methods. Note that the order of calls matters.</p>
<p>There’s one rule that we will follow: each node, when emitted, will produce assembly code that will put its result into the register <code>r0</code>. This is alredy how function calls work, but we extend it for all nodes that produce a value. This way, we will know where each value ends up when we emit it.</p>
<h2 id="test-bench">Test bench</h2>
<p>To test our emitter pass as we develop it, I suggest adding a few temporary AST nodes: <code>Main</code> and <code>Assert</code>. As we teach our compiler to emit each kind of node, we want to see the results immediately, not until we can define a somewhat complicated function like <code>assert</code>, so we make it into a primitive. It’s the same with <code>Main</code>: we want our compiler to produce an entry point to our program before we can define functions. We define <code>Main</code> to take an array of statements.</p>
<!-- It will arrange an entry point and an exit point for them. -->
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Main <span class="kw">implements</span> AST {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">statements</span><span class="op">:</span> <span class="bu">Array</span><span class="op">&lt;</span>AST<span class="op">&gt;</span>) {}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() { <span class="co">/* </span><span class="al">TODO</span><span class="co"> */</span> }</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>While <code>Assert</code> takes a single <code>condition</code> on which it will make the assertion:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Assert <span class="kw">implements</span> AST {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">condition</span><span class="op">:</span> AST) {}</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() { <span class="co">/* </span><span class="al">TODO</span><span class="co"> */</span> }</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We’ve left out the <code>emit</code> methods for now.</p>
<p>We sligtly modify the <code>functionStatement</code> parser to temporarily produce the <code>Main</code> node, in case the function name is <code>main</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// functionStatement &lt;-</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">//   FUNCTION ID LEFT_PAREN parameters RIGHT_PAREN</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">//   blockStatement</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> functionStatement<span class="op">:</span> Parser<span class="op">&lt;</span>AST<span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  FUNCTION<span class="op">.</span><span class="fu">and</span>(ID)<span class="op">.</span><span class="fu">bind</span>((name) <span class="kw">=&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    LEFT_PAREN<span class="op">.</span><span class="fu">and</span>(parameters)<span class="op">.</span><span class="fu">bind</span>((parameters) <span class="kw">=&gt;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      RIGHT_PAREN<span class="op">.</span><span class="fu">and</span>(blockStatement)<span class="op">.</span><span class="fu">bind</span>((block) <span class="kw">=&gt;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">constant</span>(</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>          name <span class="op">===</span> <span class="st">&#39;main&#39;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">?</span> <span class="kw">new</span> <span class="fu">Main</span>(block<span class="op">.</span><span class="at">statements</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="kw">new</span> <span class="bu">Function</span>(name<span class="op">,</span> parameters<span class="op">,</span> block)))))<span class="op">;</span></span></code></pre></div>
<p>Same with <code>Assert</code>: we produce it inside the <code>call</code> parser in case the callee is called <code>assert</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// call &lt;- ID LEFT_PAREN args RIGHT_PAREN</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> call<span class="op">:</span> Parser<span class="op">&lt;</span>AST<span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  ID<span class="op">.</span><span class="fu">bind</span>((callee) <span class="kw">=&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    LEFT_PAREN<span class="op">.</span><span class="fu">and</span>(args<span class="op">.</span><span class="fu">bind</span>((args) <span class="kw">=&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      RIGHT_PAREN<span class="op">.</span><span class="fu">and</span>(<span class="fu">constant</span>(</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        callee <span class="op">===</span> <span class="st">&#39;assert&#39;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">?</span> <span class="kw">new</span> <span class="fu">Assert</span>(args[<span class="dv">0</span>])</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">:</span> <span class="kw">new</span> <span class="fu">Call</span>(callee<span class="op">,</span> args))))))<span class="op">;</span></span></code></pre></div>
<p>As soon as we have enough functionality to define our own functions like <code>assert</code>, we’ll be able to roll this back.</p>
<h2 id="main-entry-point">Main entry point</h2>
<p>Let’s imagine how our main entry point should look like in assembly.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">.</span><span class="at">global</span> main</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main<span class="op">:</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  push {fp<span class="op">,</span> lr}</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  mov r0<span class="op">,</span> #<span class="dv">0</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  pop {fp<span class="op">,</span> pc}</span></code></pre></div>
<p>As before, we need the <code>main</code> label declared as <code>.global</code>. We won’t strictly need it until we implement calls, but let’s save the <code>lr</code> register, so it won’t get clobbered eventually, and we can safely return from <code>main</code>. Since we need to align the stack at the double-word boundary, we can push some other register together with <code>lr</code>. We could push <code>ip</code> as a dummy, but why not as well push the frame pointer <code>fp</code> to get the “classical” function prologue going. Then we generate the inner statements. We set the return value to zero, which will be the default return code of the program. We finish with the “classical” epilogue, where we restore <code>fp</code> and by pushing the saved <code>lr</code> into <code>pc</code> we return from <code>main</code> as well.</p>
<p>Now we can implement the <code>emit</code> method of <code>Main</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Main <span class="kw">implements</span> AST {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">statements</span><span class="op">:</span> <span class="bu">Array</span><span class="op">&lt;</span>AST<span class="op">&gt;</span>) {}</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`.global main`</span>)<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`main:`</span>)<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  push {fp, lr}`</span>)<span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">statements</span><span class="op">.</span><span class="fu">forEach</span>((statement) <span class="kw">=&gt;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      statement<span class="op">.</span><span class="fu">emit</span>()</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  mov r0, #0`</span>)<span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  pop {fp, pc}`</span>)<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Inbetween the prologue and the epilogue, we emit the inner statements in order, using <code>forEach</code> loop. Though, we haven’t defined any of the statement nodes that could be emitted here yet. Nevertheless, our <code>Main</code> node is enough to make the first test for our emitter pass: a program that does nothing successfully!</p>
<p>When testing the emitter pass, we could do that in isolation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="fu">Main</span>([])<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span></code></pre></div>
<p>Or we could integrate it with the parser:</p>
<!-- TODO

In 8.2 On page 107:
The code "parser.parseStringToCompletion(`function main(){ }`).emit();"
did not run in my implementation, as the final "parser" defined on page
62 always returns a "Block" and at this point we only defined "emit" for
"Main"s.
This happens even with the "function" parser modified according to 8.1.

-->
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>parser<span class="op">.</span><span class="fu">parseStringToCompletion</span>(<span class="vs">`</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="vs">  function main() {</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="vs">  }</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="vs">`</span>)<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span></code></pre></div>
<p>We can pipe the resulting assembly into a file, assemble it and execute it!</p>
<!-- TODO shell commands for this? -->
<p>Congratulations, our compiler has just compiled its first program end-to-end!</p>
<h2 id="assert">Assert</h2>
<p>Like a function call, assert will expect its only argument to be located in the <code>r0</code> register. We compare it with <code>1</code> which we treat as a truthy value in our untyped language with no proper booleans. If equal, we save an ASCII code for dot into <code>r0</code> to signify success. Otherwise, we save the code for <code>F</code> to signify failure. We call <code>putchar</code> from <code>libc</code> to print it. We do not terminate the program.</p>
<!-- TODO talk about that our language is unityped/untyped -->
<!-- TODO change truthiness: 0 is false, all else is true -->
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  cmp r0<span class="op">,</span> #<span class="dv">1</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  moveq r0<span class="op">,</span> #<span class="st">&#39;.&#39;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  movne r0<span class="op">,</span> #<span class="st">&#39;F&#39;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  bl putchar</span></code></pre></div>
<p>To implement the <code>Assert</code> node, we just copy-paste this assembly into the <code>emit</code> method. We also make sure to emit the condition, so the result ends up in <code>r0</code>. We don’t have any nodes that could be emitted here yet, but that will change quickly.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Assert <span class="kw">implements</span> AST {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">condition</span><span class="op">:</span> AST) {}</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">condition</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  cmp r0, #1`</span>)<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  moveq r0, #&#39;.&#39;`</span>)<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  movne r0, #&#39;F&#39;`</span>)<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  bl putchar`</span>)<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="number">Number</h2>
<p>Let’s start with the node for a literal integer. This way, we can put our <code>Assert</code> to use as soon as possible.</p>
<p>We need to load the integer value into <code>r0</code>. We could use <code>mov</code> with an immediate, but the range of immediate values is quite restrictive. That’s why we use the <code>ldr</code> pseudo-instruction. As you remember, the assembler will convert it into <code>mov</code> with an immediate, if possible.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Number</span> <span class="kw">implements</span> AST {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">value</span><span class="op">:</span> number) {}</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  ldr r0, =</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">value</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now, we can use <code>Number</code> in an assertion.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>parser<span class="op">.</span><span class="fu">parseStringToCompletion</span>(<span class="vs">`</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="vs">  function main() {</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="vs">    assert(1);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="vs">  }</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="vs">`</span>)<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span></code></pre></div>
<p>We compile, assemble, and run this program, and we can see that it prints a mighty dot, signifying that the assertion passes. If you change the integer to 0, you can see the program prints <code>F</code>, as it should.</p>
<h2 id="negation">Negation</h2>
<p>Next up is the negation operator! It is, to some degree, similar to <code>Assert</code>. It takes a single term, that we emit, and compares it to zero. Depending on that, we move either <code>1</code> or <code>0</code> into <code>r0</code>, thus logically negating the result.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Not <span class="kw">implements</span> AST {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">term</span><span class="op">:</span> AST) {}</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">term</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  cmp r0, #0`</span>)<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  moveq r0, #1`</span>)<span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  movne r0, #0`</span>)<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now we can extend our test program:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="op">!</span><span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<!-- TODO consider allowing !!1 instead of !(!1) -->
<p>From here on, we will skip the boilerplate when we discuss our test program.</p>
<h2 id="infix-operators">Infix operators</h2>
<p>Next up are infix operators: <code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> with nodes <code>Equal</code>, <code>NotEqual</code>, <code>Add</code>, <code>Subtract</code>, <code>Multiply</code>, <code>Divide</code>. All of them are very similar: they take two terms <code>left</code> and <code>right</code> and operate on them.</p>
<p>Let’s use <code>Add</code> as an example.</p>
<p>We could emit one node, move the value into a temporary register (say, <code>r1</code>), then emit the second node (which value ends up in <code>r0</code>) and then sum them up:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Add <span class="kw">implements</span> AST {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">left</span><span class="op">:</span> AST<span class="op">,</span> <span class="kw">public</span> <span class="dt">right</span><span class="op">:</span> AST) {}</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() { <span class="co">/* First flawed attempt */</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">left</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`mov r1, r0`</span>)<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">right</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`add r0, r1, r0`</span>)<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>However, this will not work for long: as soon as the <code>right</code> node is something more complicated than just a <code>Number</code>, emitting it will likely clobber <code>r1</code> that stores the <code>left</code> result. This will be the case, for example, if we have two nested infix nodes. That’s why we need to save <code>r1</code> onto the stack before emitting <code>right</code>, then restore it before we perform the addition:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() { <span class="co">/* Second attempt */</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">left</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`push {r0, ip}`</span>)<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">right</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`pop {r1, ip}`</span>)<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`add r0, r1, r0`</span>)<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>To maintain 8-byte stack alignment, we also save and restore the dummy <code>ip</code> register. If the <code>left</code> node is another nested expression, the pushes and pops will match, and we will be at the same stack pointer location before and after we emit it.</p>
<p>Like in our first attempt, we can avoid using stack in some cases. We can also do better than waste stack space on saving <code>ip</code> each time. <!-- We will explore it further in *Optimizations* chapter in *Part II*. --></p>
<!-- TODO Optimizations chapter -->
<!-- TODO contract: stack is the same place after emit -->
<p>All our infix operators will have the same structure: emit right, push, emit left, pop, then the action. Only the last part will be different. So, here is a quick table that shows the action part of each infix node.</p>
<table style="width:65%;">
<caption>Action part of each infix node</caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>AST Node</th>
<th>Emits</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>Add</code></td>
<td><div class="sourceCode" id="cb23"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>add r0<span class="op">,</span> r1<span class="op">,</span> r0</span></code></pre></div></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>Subtract</code></td>
<td><div class="sourceCode" id="cb24"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>sub r0<span class="op">,</span> r1<span class="op">,</span> r0</span></code></pre></div></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>Multiply</code></td>
<td><div class="sourceCode" id="cb25"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>mul r0<span class="op">,</span> r1<span class="op">,</span> r0</span></code></pre></div></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>Divide</code></td>
<td><div class="sourceCode" id="cb26"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>udiv r0<span class="op">,</span> r1<span class="op">,</span> r0</span></code></pre></div></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>Equal</code></td>
<td><div class="sourceCode" id="cb27"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>cmp r0<span class="op">,</span> r1</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>moveq r0<span class="op">,</span> #<span class="dv">1</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>movne r0<span class="op">,</span> #<span class="dv">0</span></span></code></pre></div></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>NotEqual</code></td>
<td><div class="sourceCode" id="cb28"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>cmp r0<span class="op">,</span> r1</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>moveq r0<span class="op">,</span> #<span class="dv">0</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>movne r0<span class="op">,</span> #<span class="dv">1</span></span></code></pre></div></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>If you want to reduce duplication, you can pull the common part into a new AST node called <code>Infix</code>, for example.</p>
<p>In the end, we can add an integration test for infix operators:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="op">!</span><span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">42</span> <span class="op">==</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">3</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">+</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We are getting somewhere!</p>
<h2 id="block-statement">Block statement</h2>
<p>Block statement is similar to <code>Main</code> but without all the entry point fuss. It merely emits each statement.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Block <span class="kw">implements</span> AST {</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">statements</span><span class="op">:</span> <span class="bu">Array</span><span class="op">&lt;</span>AST<span class="op">&gt;</span>) {}</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">statements</span><span class="op">.</span><span class="fu">forEach</span>((statement) <span class="kw">=&gt;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>      statement<span class="op">.</span><span class="fu">emit</span>()</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Simple test:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="op">!</span><span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">42</span> <span class="op">==</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">3</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">+</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  { <span class="co">/* Testing a block statement */</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="function-calls">Function calls</h2>
<p>Next is function calls. As we learned in the previous chapter, according to the ARM calling convention we need to put the first four arguments into registers <code>r0</code>–<code>r3</code>, and expect the return value in <code>r0</code>. Let’s remind ourselves that the <code>Call</code> node holds a <code>callee</code> string and an <code>args</code> array.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Call <span class="kw">implements</span> AST {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">callee</span><span class="op">:</span> string<span class="op">,</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">args</span><span class="op">:</span> <span class="bu">Array</span><span class="op">&lt;</span>AST<span class="op">&gt;</span>) {}</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    …</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We can start with something simple: calling a function with no arguments. That’s just branching-and-link to the callee label:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// One argument</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="vs">`  bl </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">callee</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span></code></pre></div>
<p>How about one argument? If we emit the first argument, it will be in <code>r0</code>. And that’s precisely where we need it! Then we <code>bl</code> to it, as previously:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Two arguments</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">args</span>[<span class="dv">0</span>]<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="vs">`  bl </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">callee</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span></code></pre></div>
<p>More arguments? We could have special cases for two, three, and four arguments, and it would also be good for performance reasons, but how about we jump straight to a more general case. The following will handle two, three, or four arguments. It was nice not to use any stack space for zero or one arguments. However, to evaluate more arguments, we need to put them on the stack temporarily. Otherwise, as we evaluate one, we risk clobbering the value of the other arguments. Here’s how we do it:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Up to four arguments</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="vs">`  sub sp, sp, #16`</span>)<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">args</span><span class="op">.</span><span class="fu">forEach</span>((arg<span class="op">,</span> i) <span class="kw">=&gt;</span> {</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    arg<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  str r0, [sp, #</span><span class="sc">${</span><span class="dv">4</span> <span class="op">*</span> i<span class="sc">}</span><span class="vs">]`</span>)<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="vs">`  pop {r0, r1, r2, r3}`</span>)<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="vs">`  bl </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">callee</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span></code></pre></div>
<p>First, we allocate enough stack space for up to four arguments, or in other words, 16 bytes. We do that by subtracting from the stack pointer since the stack grows from higher memory addresses to lower. Then we loop through arguments using <code>forEach</code>, which takes a callback with each item, and optionally its index <code>i</code>. For each argument, we first emit it and then store the result into each stack slot. We multiply by four to convert array indexes <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> into stack offsets in bytes: <code>0</code>, <code>4</code>, <code>8</code>, <code>12</code>. At this point, the arguments will all be emitted and stored on the stack. However, we want them to be in registers. So we <code>pop</code> them into the registers in one elegant go. Now, we’ve got everything in place so we can branch to the label.</p>
<p>Here’s the complete version that combines all three approaches by dispatching on the number of arguments.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Call <span class="kw">implements</span> AST {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">callee</span><span class="op">:</span> string<span class="op">,</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">args</span><span class="op">:</span> <span class="bu">Array</span><span class="op">&lt;</span>AST<span class="op">&gt;</span>) {}</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> count <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="at">args</span><span class="op">.</span><span class="at">length</span><span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (count <span class="op">===</span> <span class="dv">0</span>) {</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  bl </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">callee</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (count <span class="op">===</span> <span class="dv">1</span>) {</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">args</span>[<span class="dv">0</span>]<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  bl </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">callee</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (count <span class="op">&gt;=</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> count <span class="op">&lt;=</span> <span class="dv">4</span>) {</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  sub sp, sp, #16`</span>)<span class="op">;</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">args</span><span class="op">.</span><span class="fu">forEach</span>((arg<span class="op">,</span> i) <span class="kw">=&gt;</span> {</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        arg<span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">emit</span>(<span class="vs">`  str r0, [sp, #</span><span class="sc">${</span><span class="dv">4</span> <span class="op">*</span> i<span class="sc">}</span><span class="vs">]`</span>)<span class="op">;</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>      })<span class="op">;</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  pop {r0, r1, r2, r3}`</span>)<span class="op">;</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  bl </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">callee</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">Error</span>(<span class="st">&quot;More than 4 arguments: not supported&quot;</span>)<span class="op">;</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We throw an error in the case of more than four arguments, which we don’t support in the baseline compiler.</p>
<blockquote>
<p><strong>Explore</strong></p>
<p>By specializing code generators for two, three, and four arguments separately (like we did for zero and one argument) you will be able to produce better code (for example, not allocate four slots for two arguments, like we do now). From the previous chapter you might have an idea about how to handle more than four arguments.</p>
</blockquote>
<p>How do we test this? We don’t yet have a way to define functions. But we can use some of the <code>libc</code> functions to test this.</p>
<p>As you remember, <code>putchar</code> takes one parameter: let’s put it into use by printing the ASCII code for a dot (46), as our test.</p>
<p>There’s also a function called <code>rand</code> that takes no arguments and returns a random number. That’s not the best function to base our tests on, but we can use it until we can define our own functions.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putchar</span>(<span class="dv">46</span>)<span class="op">;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">assert</span>(<span class="fu">rand</span>() <span class="op">!=</span> <span class="dv">42</span>)<span class="op">;</span></span></code></pre></div>
<p>I couldn’t find any portable <code>libc</code> function that takes two, three, or four integer arguments, so we’ll have to wait to test that.</p>
<blockquote>
<p><strong>Explore</strong></p>
<p>Modify the parser such that a character literal like <code>'.'</code> produces an AST node with the corresponding ASCII code, like <code>new Number(46)</code>. You can use <code>string.charCodeAt(index)</code> method.</p>
</blockquote>
<h2 id="if-statement">If-statement</h2>
<p>Next one is fun: conditional statement, or, in other words, if-statement. It is fun because we are finally getting to work with control-flow.</p>
<p>Let’s look at an example first. What if we wanted to compile the following if-statement:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">rand</span>()) {   <span class="co">/* Conditional */</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putchar</span>(<span class="dv">46</span>)<span class="op">;</span>  <span class="co">/* Consequence */</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putchar</span>(<span class="dv">70</span>)<span class="op">;</span>  <span class="co">/* Alternative */</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>How would we compile this by hand? We could start with two labels <code>ifTrue</code> and <code>ifFalse</code>. We branch to <code>ifFalse</code> if the condition is zero, otherwise to <code>ifTrue</code>. Below each of these labels, we emit the code corresponding to that branch. In the end, we put an <code>endIf</code> label and make sure that both branches jump to it when they reach their end.</p>
<!--Here's what we get:-->
<div class="sourceCode" id="cb39"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>  bl rand</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  cmp r0<span class="op">,</span> #<span class="dv">0</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  beq ifFalse</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  bne ifTrue</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>ifTrue<span class="op">:</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  ldr r0<span class="op">,</span> <span class="op">=</span><span class="dv">46</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  bl putchar</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  b endIf</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>ifFalse<span class="op">:</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  ldr r0<span class="op">,</span> <span class="op">=</span><span class="dv">70</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  bl putchar</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  b endIf</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>endIf<span class="op">:</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Whatever follows next */</span></span></code></pre></div>
<p>We can do precisely that, but there are few improvements that we can make, to reduce the number of instructions. First, the <code>ifFalse</code> branch ends with <code>b endIf</code> immediately followed by <code>endIf:</code> label. That means we don’t have to jump to it since it points to the next instruction anyway. Similar with <code>bne ifTrue</code>, but with one nuance: although this branch is conditional (<code>ne</code> suffix), it is in fact not. Since the two conditions <code>beq</code> and <code>bne</code> are mutually exclusive, if the execution reached <code>bne ifTrue</code> we already know that it will execute. Furthermore, since <code>bne ifTrue</code> is the only use of this label, we can remove <code>ifTrue</code> completely. Here’s the resulting code:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>  bl rand</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  cmp r0<span class="op">,</span> #<span class="dv">0</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  beq ifFalse</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  ldr r0<span class="op">,</span> <span class="op">=</span><span class="dv">46</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  bl putchar</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  b endIf</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>ifFalse<span class="op">:</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  ldr r0<span class="op">,</span> <span class="op">=</span><span class="dv">70</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  bl putchar</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>endIf<span class="op">:</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Whatever follows next */</span></span></code></pre></div>
<p>It is shorter, has fewer branches, so it can be executed more efficiently. But before we jump straight to implementing this in our emitter, we need to solve one problem. We can’t have two different labels called <code>ifFalse</code> or <code>endIf</code>: labels must be unique. We need to generate unique labels.</p>
<hr />
<p>By convention, labels starting with prefix <code>.L</code>, for example, <code>.L123</code> are used for code generation. Let’s create a class that will help us generate such labels.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Label {</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">value</span><span class="op">:</span> number<span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>() {</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">value</span> <span class="op">=</span> Label<span class="op">.</span><span class="at">counter</span><span class="op">++;</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">toString</span>() {</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="vs">`.L</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">value</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This class has a global <code>counter</code> which is incremented each time the constructor is called. When a <code>Label</code> object is created, this counter value is stored in the object’s <code>value</code> instance variable. We define a <code>toString</code> method that adds the <code>.L</code> prefix, so that these objects work well with string interpolation.</p>
<hr />
<p>Now we have all things in place to implement the emitter. We crate two label objects <code>ifFalseLabel</code> and <code>endIfLabel</code> and use them with string interpolation in the <code>emit</code> calls.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> If <span class="kw">implements</span> AST {</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">conditional</span><span class="op">:</span> AST<span class="op">,</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">consequence</span><span class="op">:</span> AST<span class="op">,</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">alternative</span><span class="op">:</span> AST) {}</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ifFalseLabel <span class="op">=</span> <span class="kw">new</span> <span class="fu">Label</span>()<span class="op">;</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> endIfLabel <span class="op">=</span> <span class="kw">new</span> <span class="fu">Label</span>()<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">conditional</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  cmp r0, #0`</span>)<span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  beq </span><span class="sc">${</span>ifFalseLabel<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">consequence</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  b </span><span class="sc">${</span>endIfLabel<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`</span><span class="sc">${</span>ifFalseLabel<span class="sc">}</span><span class="vs">:`</span>)<span class="op">;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">alternative</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`</span><span class="sc">${</span>endIfLabel<span class="sc">}</span><span class="vs">:`</span>)<span class="op">;</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now all of our if-statements will have unique labels!</p>
<p>We can throw in a small unit test, for good measure:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="dv">1</span>) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="dv">0</span>) {</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="function-definition-and-variable-look-up">Function definition and variable look-up</h2>
<p>It was nice that we could develop and test function calls in isolation, without even being able to define functions. However, the next two concepts are highly intertwined: function definition and variable look-up. We already have a special node called <code>Main</code> that could be thought of as a function that takes no parameters, and always returns <code>0</code>. We will use it as a template for making our <code>Function</code> node’s emitter:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Function</span> <span class="kw">implements</span> AST {</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">name</span><span class="op">:</span> string<span class="op">,</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">parameters</span><span class="op">:</span> <span class="bu">Array</span><span class="op">&lt;</span>string<span class="op">&gt;,</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">body</span><span class="op">:</span> AST) {}</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* First attempt */</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>() {</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="kw">this</span><span class="op">.</span><span class="at">parameters</span><span class="op">.</span><span class="at">length</span> <span class="op">&gt;</span> <span class="dv">4</span>)</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">Error</span>(<span class="st">&quot;More than 4 parameters: not supported&quot;</span>)<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">``</span>)<span class="op">;</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`.global </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs">:`</span>)<span class="op">;</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">emitPrologue</span>()<span class="op">;</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">emit</span>()<span class="op">;</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">emitEpilogue</span>()<span class="op">;</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emitPrologue</span>() {</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  push {fp, lr}`</span>)<span class="op">;</span></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  mov fp, sp`</span>)<span class="op">;</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  push {r0, r1, r2, r3}`</span>)<span class="op">;</span></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emitEpilogue</span>() {</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  mov sp, fp`</span>)<span class="op">;</span></span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  mov r0, #0`</span>)<span class="op">;</span></span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  pop {fp, pc}`</span>)<span class="op">;</span></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>() {…}</span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Similar to <code>Call</code> we will limit ourselves to four parameters this time. We make a guard to enforce this and raise an error otherwise. We start by emitting an empty line to separate assembly functions for readability. Similarly to <code>Main</code>, we emit the <code>.global</code> directive and the label. However, this time we don’t hardcode it to <code>main</code>, but use the name of the function instead, using string interpolation.</p>
<p>Here the function prologue starts. We have split the function prologue and epilogue into its own methods for readability. This is not something that we have done before.</p>
<p>Let’s look at the prologue, first. We save the frame pointer and the link registers, and we set our new frame pointer. We expect our parameters to be in registers <code>r0</code>–<code>r3</code>. However, as soon as we start emitting the body of the function, we risk clobbering them, so we need to save them on the stack. Fortunately, ARM allows us to do it with a single <code>push</code> instruction. (An optimizing compiler would make an analysis called register allocation to determine which parameters can be kept in registers.)</p>
<p>Next, we emit the body of the function, which is followed by the function epilogue. Here we undo the effect of the function prologue: by setting the stack pointer value to frame pointer value we effectively deallocate whatever stack space we allocated (in the prologue, or otherwise). We set <code>r0</code> and thus our return value to <code>0</code>. This is to mimic the fact that JavaScript functions return <code class="sourceCode javascript"><span class="kw">undefined</span></code> when there’s no explicit return. We pick <code>0</code> because it is falsy, like <code class="sourceCode javascript"><span class="kw">undefined</span></code>. This also removes the risk of returning a garbage value that was a leftover of some computation, in case we forget to have a <code class="sourceCode javascript"><span class="cf">return</span></code> statement. As the last instruction, we restore the caller’s frame pointer and pop the saved link register into the program counter, effectively returning from the function.</p>
<blockquote>
<p><strong>Explore</strong></p>
<p>We pushed four registers onto the stack. An improvement could be to specialize this code to handle the cases with fewer parameters more efficiently. If you do that, don’t forget about 8-byte stack alignment.</p>
</blockquote>
<p>So far, so good. Now, how do we access those parameters in the body of the function? They are located at well-known offsets from the frame pointer. Since the stack grows from high addresses to low, we know that we can access parameters using negative offsets relative to the frame pointer. We also know that <code>push {r0, r1, r2, r3}</code> pushes the registers in the reverse order, same as this equivalent (but bulkier) code:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>  push {r3}</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  push {r2}</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  push {r1}</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  push {r0}</span></code></pre></div>
<p>That means that the fourth parameter (from register <code>r3</code>) will be stored at the location <code>fp - 4</code>, third (<code>r2</code>) at <code>fp - 8</code>, second (<code>r1</code>) at <code>fp - 12</code>, first at <code>fp - 16</code>.</p>
<p>So, when we encounter an identifier that refers to one of the parameters, all we need to know is the offset from the frame pointer to locate its value. We can load it with <code>ldr</code>. Here’s an example of loading the first parameter:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>  ldr r0<span class="op">,</span> [fp<span class="op">,</span> #<span class="op">-</span><span class="dv">16</span>]</span></code></pre></div>
<p>What we can do is to store the mapping from parameter name to an offset from the frame pointer and make sure it is passed down to all emitters. That means that whenever we encounter an identifier node <code>Id</code> we can look up the offset in that mapping and then we will know how to load it. This mapping is usually called an <em>environment</em>.</p>
<p>We could just pass around a <code>Map&lt;string, number&gt;</code>, but my crystal ball tells me that we will need to extend this data structure in the near future. So, instead we will introduce a data class with this map as an instance variable called <code>locals</code>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Environment {</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Initial version */</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">locals</span><span class="op">:</span> <span class="bu">Map</span><span class="op">&lt;</span>string<span class="op">,</span> number<span class="op">&gt;</span>) {}</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We call this class <code>Environment</code>. Right now it only contains the <code>locals</code> map, which is the environment for our local variables, but it could include other environments, such as global variable environment, or type environments, or an environment with function signatures. We called our map <code>locals</code> and not <code>parameters</code>, because we foresee that we will use it for other local variables, and not just for function parameters. <!--It often grows to hold much more, and then a good name for it could be a more general `Context`.--></p>
<!--
In the `Environment` constructor, we make the `locals` parameter optional with the default value being an empty map.
This is a mutable map, which we will modify.
Fortunately, JavaScript default values are evaluated on each call so that we will get a new mutable map each time.
But this is not the case in some of the other languages.
-->
<p>Now, there is a hefty change that we need to make. We need to adjust the <code>AST</code> interface to take the new <code>Environment</code> parameter, which we will pass to <code>emit</code>. We will consistently call this parameter <code>env</code>.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> AST {</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean<span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This will also require us to modify all AST nodes to take this environment and pass it down to all other node emitters. This is a very invasive, but mechanical change. We’ll not go through all the nodes for this, let’s just use <code>Add</code> as our example.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Add <span class="kw">implements</span> AST {</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">left</span><span class="op">:</span> AST<span class="op">,</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">right</span><span class="op">:</span> AST) {}</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment) {</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">left</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  push {r0, ip}`</span>)<span class="op">;</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">right</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  pop {r1, ip}`</span>)<span class="op">;</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  add r0, r1, r0`</span>)<span class="op">;</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The emitter now takes an <code>env</code> parameter, which it passes down to both its child AST nodes: <code>left</code> and <code>right</code>, in this case.</p>
<p>Now, back to our <code>Function</code>. We need to modify it to fulfil the new <code>AST</code> interface with <code>Environment</code>. However, we will ignore the incoming environment since we will not support nested functions. We will bind it to an underscore to signify to the reader of this code that this variable is not used on purpose. Here’s our new take on function definition:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Function</span> <span class="kw">implements</span> AST {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Second attempt */</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">_</span><span class="op">:</span> Environment) {</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="kw">this</span><span class="op">.</span><span class="at">parameters</span><span class="op">.</span><span class="at">length</span> <span class="op">&gt;</span> <span class="dv">4</span>)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">Error</span>(<span class="st">&quot;More than 4 parameters: not supported&quot;</span>)<span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">``</span>)<span class="op">;</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`.global </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs">:`</span>)<span class="op">;</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">emitPrologue</span>()<span class="op">;</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> env <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="fu">setUpEnvironment</span>()<span class="op">;</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">emitEpilogue</span>()<span class="op">;</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setUpEnvironment</span>() {</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> locals <span class="op">=</span> <span class="kw">new</span> <span class="bu">Map</span>()<span class="op">;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">parameters</span><span class="op">.</span><span class="fu">forEach</span>((parameter<span class="op">,</span> i) <span class="kw">=&gt;</span> {</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>      locals<span class="op">.</span><span class="fu">set</span>(parameter<span class="op">,</span> <span class="dv">4</span> <span class="op">*</span> i <span class="op">-</span> <span class="dv">16</span>)<span class="op">;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="fu">Environment</span>(locals)<span class="op">;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here, in the function definition node, we know both the names of the parameters and the offsets at which they will be stored. So this is the ideal place to create a new environment. We do that in a method called <code>setUpEnvironment</code>. First, we create an empty environment, and then we loop through the parameters using <code>forEach</code> and set the locals map for each parameter to its offset relative to the frame pointer. Here, <code>forEach</code> passes not only items but also (optionally) each item’s index <code>i</code>. To map each index to its frame pointer offset we multiply the index by four to convert from words to bytes, and remove <code>16</code> since this is how many bytes we had allocated on the stack when we popped the four parameters in the prologue. We pass the constructed environment when emitting the body, which, in turn, will pass it to all its children, and so forth.</p>
<p>Now, a node that needs to access a local parameter can look it up in the environment. And what node could it be if not <code>Id</code>, the node for the identifiers in our code? All the hard work is done in the <code>Function</code> node, so our <code>Id</code> node will be quite simple:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Id <span class="kw">implements</span> AST {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">value</span><span class="op">:</span> string) {}</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment) {</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> offset <span class="op">=</span> env<span class="op">.</span><span class="at">locals</span><span class="op">.</span><span class="fu">get</span>(<span class="kw">this</span><span class="op">.</span><span class="at">value</span>)<span class="op">;</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (offset) {</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  ldr r0, [fp, #</span><span class="sc">${</span>offset<span class="sc">}</span><span class="vs">]`</span>)<span class="op">;</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">Error</span>(<span class="vs">`Undefined variable: </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">value</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>() {…}</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>It looks up the offset from the local environment by identifier name. If the name is not in the environment, it throws an error. This means that a variable was used before it is defined. Otherwise, it loads the value using <code>ldr</code> relative to the frame pointer.</p>
<p>These frame pointers are handy, aren’t they?</p>
<p>Now that we have implemented functions with parameters, we can implement quite a few interesting ones! First, we can get rid of the <code>Main</code> node, and generate the <code>main</code> function just like any other. Second, we can get rid of our <code>Assert</code> primitive, and implement it instead as a function:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assert</span>(x) {</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (x) {</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putchar</span>(<span class="dv">46</span>)<span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putchar</span>(<span class="dv">70</span>)<span class="op">;</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Finally, it’s good to test that we got parameter passing right. Here’s one of such tests:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">assert1234</span>(a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> d) {</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(a <span class="op">==</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(b <span class="op">==</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(c <span class="op">==</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">assert</span>(d <span class="op">==</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>It could be called as <code>assert1234(1, 2, 3, 4)</code> from <code>main</code>.</p>
<p>It feels like we can implement almost anything now; however, one critical piece is still missing.</p>
<h2 id="return">Return</h2>
<p>Functions must be able to return values. Even fans of continuation-passing style would agree. And thanks to frame pointers, implementing the <code>Return</code> node is easy:</p>
<!-- TODO consistently order epilogue instructions: Main, Return, FD -->
<!-- TODO check equals function signature in the book for `other` param -->
<div class="sourceCode" id="cb55"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Return <span class="kw">implements</span> AST {</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">term</span><span class="op">:</span> AST) {}</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(env) {</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">term</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  mov sp, fp`</span>)<span class="op">;</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  pop {fp, pc}`</span>)<span class="op">;</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We only need to emit the node (which is returned) into <code>r0</code>, and then repeat the same instructions as in the epilogue.</p>
<p>Now, the language of our compiler is technically-speaking Turing-complete. Loops, you say? We can loop using recursion, which we get for free since our functions are using the stack. (We are not getting tail-call optimization for free, though). This step warrants extensive testing, but the one test I have in mind is this:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">factorial</span>(n) {</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (n <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">*</span> <span class="fu">factorial</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The factorial function! We can call it from <code>main</code> as follows:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">assert</span>(<span class="fu">factorial</span>(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">120</span>)<span class="op">;</span></span></code></pre></div>
<p>It’s a small dot for a test suite, but a giant leap for our compiler!</p>
<hr />
<p>We’ve got all the essentials in place now. We will finish this chapter with a couple of niceties: local variables, assignments, and while loops. As a treat.</p>
<h2 id="local-variables">Local variables</h2>
<p>Here we will set out to implement local variables, as declared with <code class="sourceCode javascript"><span class="kw">var</span></code> keyword in JavaScript and represented as <code>Var</code> node in our AST.</p>
<p>Why <code class="sourceCode javascript"><span class="kw">var</span></code> and not <code class="sourceCode javascript"><span class="kw">let</span></code>? We have used only <code class="sourceCode javascript"><span class="kw">let</span></code> in the implementation of this compiler!</p>
<p>Let’s remind ourselves of the difference. Here’s a function using <code class="sourceCode javascript"><span class="kw">let</span></code>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">f</span>() {</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x)<span class="op">;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>And the same one using <code class="sourceCode javascript"><span class="kw">var</span></code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">f</span>() {</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x)<span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The first one prints <code>1</code>, and the second one prints <code>2</code>. The difference is that the <code class="sourceCode javascript"><span class="kw">var</span></code> bindings work at the function scope, and <code class="sourceCode javascript"><span class="kw">let</span></code> bindings work at the block scope. So the two “vars” refer to the same variables, but the two “lets” are different: the second one is within another scope delimited by braces.</p>
<p>The reason we implement <code class="sourceCode javascript"><span class="kw">var</span></code> is that it simplifies scope handling: you only need one scope per function. That’s probably also the reason JavaScript introduced <code class="sourceCode javascript"><span class="kw">var</span></code> first, and <code class="sourceCode javascript"><span class="kw">let</span></code> much later. There’s also <code class="sourceCode javascript"><span class="kw">const</span></code>, which is just like <code class="sourceCode javascript"><span class="kw">let</span></code>, but makes the assignment forbidden on its bindings.</p>
<p>So, how do we implement <code class="sourceCode javascript"><span class="kw">var</span></code>? We can push the value on the stack, then look it up in the environment, just like with parameters. However, when defining parameters, we know their offset: they are at the beginning of the frame. However, when we emit a <code class="sourceCode javascript"><span class="kw">var</span></code>, we don’t know how far down the stack we currently are. But we can track this in the environment!</p>
<p>Let’s modify the <code>Environment</code> class to store the <code>nextLocalOffset</code> number, which represents the next available frame pointer offset. This is also sometimes called a <em>stack index</em>.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Environment {</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">locals</span><span class="op">:</span> <span class="bu">Map</span><span class="op">&lt;</span>string<span class="op">,</span> number<span class="op">&gt;,</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">nextLocalOffset</span><span class="op">:</span> number) {}</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>For starters, we could initialize it to <code>0</code>. However, in <code>Function</code> we need to set it up depending on how many parameters we allocate. Right now we always allocate four, at offsets <code>-4</code>, <code>-8</code>, <code>-12</code>, and <code>-16</code>. So the next available offset is <code>-20</code>. And that’s the value that we use in the environment setup:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Function</span> <span class="kw">implements</span> AST {</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setUpEnvironment</span>() {</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> locals <span class="op">=</span> <span class="kw">new</span> <span class="bu">Map</span>()<span class="op">;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">parameters</span><span class="op">.</span><span class="fu">forEach</span>((parameter<span class="op">,</span> i) <span class="kw">=&gt;</span> {</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>      locals<span class="op">.</span><span class="fu">set</span>(parameter<span class="op">,</span> <span class="dv">4</span> <span class="op">*</span> i <span class="op">-</span> <span class="dv">16</span>)<span class="op">;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>    nextLocalOffset <span class="op">=</span> <span class="op">-</span><span class="dv">20</span><span class="op">;</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="fu">Environment</span>(locals<span class="op">,</span> nextLocalOffset)<span class="op">;</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  …</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now, onto the <code>Var</code> node. Theoretically, we could add the variable name to the <code>local</code> environment mapping, so it maps to the <code>nextLocalOffset</code> value, then push the value onto the stack, and update the <code>nextLocalOffset</code> to point to the next available offset. However, we need to maintain 8-byte alignment, so it is slightly more involved:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Var <span class="kw">implements</span> AST {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">name</span><span class="op">:</span> string<span class="op">,</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">value</span><span class="op">:</span> AST) {}</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment) {</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  push {r0, ip}`</span>)<span class="op">;</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    env<span class="op">.</span><span class="at">locals</span><span class="op">.</span><span class="fu">set</span>(<span class="kw">this</span><span class="op">.</span><span class="at">name</span><span class="op">,</span> env<span class="op">.</span><span class="at">nextLocalOffset</span> <span class="op">-</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    env<span class="op">.</span><span class="at">nextLocalOffset</span> <span class="op">-=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We still start by emitting the value and pushing it onto the stack, but we also need to push something like an <code>ip</code> register to keep the stack 8-byte aligned. This way it’s the <code>ip</code> that will be located at the <code>nextLocalOffset</code>, so when updating the local environment, we subtract another <code>4</code> bytes from it. Now, we need to advance <code>nextLocalOffset</code> two stack slots ahead; in other words, we decrement it by <code>8</code>.</p>
<blockquote>
<p><strong>Explore</strong></p>
<p>This wastes 50% of the stack space for locals. Here’s a way to fix it: you can add an array of offsets <code>vacantOffsets</code> to the <code>Environment</code>. Then each time you need a stack slot you first check if there are any vacant slots, and try to use it (and remove it from the array). And only if there are no such slots, you allocate new stack space. This technique can also be used to take advantage of over-allocating in other situations, for example, when you have an odd number of function parameters. There’s also a way to organize it all neatly into a <code>Frame</code> data structure that handles this offset twiddling in one place, so every relevant emitter doesn’t have to keep track of the offset math.</p>
</blockquote>
<p>Let’s add an assertion to test our <code>var</code> handling:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> x <span class="op">=</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">-</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> y <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> z <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="fu">assert</span>(z <span class="op">==</span> <span class="dv">42</span>)<span class="op">;</span></span></code></pre></div>
<h2 id="assignment">Assignment</h2>
<p>Assignment handling is very similar to identifier look-up. Except instead of reading its value, we are writing it. We emit the value into <code>r0</code>. Then we look up the frame pointer offset in the local environment. If the environment look-up fails, we throw an error: that variable was not defined at this point of time. Otherwise, we use the <code>str</code> instruction to store the value from <code>r0</code> into the frame pointer offset.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Assign <span class="kw">implements</span> AST {</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">name</span><span class="op">:</span> string<span class="op">,</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">value</span><span class="op">:</span> AST) {}</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment) {</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> offset <span class="op">=</span> env<span class="op">.</span><span class="at">locals</span><span class="op">.</span><span class="fu">get</span>(<span class="kw">this</span><span class="op">.</span><span class="at">name</span>)<span class="op">;</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (offset) {</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">emit</span>(<span class="vs">`  str r0, [fp, #</span><span class="sc">${</span>offset<span class="sc">}</span><span class="vs">]`</span>)<span class="op">;</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="bu">Error</span>(<span class="vs">`Undefined variable: </span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">name</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A simple test for the assignment:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">assert</span>(a <span class="op">==</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="fu">assert</span>(a <span class="op">==</span> <span class="dv">0</span>)<span class="op">;</span></span></code></pre></div>
<blockquote>
<p><strong>Explore</strong></p>
<p>Implement <code class="sourceCode javascript"><span class="kw">const</span></code> bindings similar to <code class="sourceCode javascript"><span class="kw">var</span></code>, but such that assignment is not allowed on them. A way to do that would be to change the locals mapping to include not only an offset but also a flag that signifies whether the binding is constant or not. Then, when the assignment looks it up, check that the constant flag is not set, and fail otherwise.</p>
</blockquote>
<h2 id="while-loop">While-loop</h2>
<p>While-loop handling is in many ways similar to the <code>If</code> statement handling. It has a conditional expression, which is checked for truthiness, but it has only one branch. The other difference is that at the end of that branch, it jumps back to the beginning.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> While <span class="kw">implements</span> AST {</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">conditional</span><span class="op">:</span> AST<span class="op">,</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">public</span> <span class="dt">body</span><span class="op">:</span> AST) {}</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment) {</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> loopStart <span class="op">=</span> <span class="kw">new</span> <span class="fu">Label</span>()<span class="op">;</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> loopEnd <span class="op">=</span> <span class="kw">new</span> <span class="fu">Label</span>()<span class="op">;</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`</span><span class="sc">${</span>loopStart<span class="sc">}</span><span class="vs">:`</span>)<span class="op">;</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">conditional</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  cmp r0, #0`</span>)<span class="op">;</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  beq </span><span class="sc">${</span>loopEnd<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`  b </span><span class="sc">${</span>loopStart<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">emit</span>(<span class="vs">`</span><span class="sc">${</span>loopEnd<span class="sc">}</span><span class="vs">:`</span>)<span class="op">;</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST) {…}</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here we generate two unique labels: <code>loopStart</code> and <code>loopEnd</code>. We check the conditional and branch off to <code>loopEnd</code> if it is falsy. Then follows the body of the loop. In the end, we unconditionally branch to the <code>loopStart</code> label. A quick test for the <code class="sourceCode javascript"><span class="cf">while</span></code> loop may look like this:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (i <span class="op">!=</span> <span class="dv">3</span>) {</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="fu">assert</span>(i <span class="op">==</span> <span class="dv">3</span>)<span class="op">;</span></span></code></pre></div>
<p>We’ve put away the <code class="sourceCode javascript"><span class="cf">while</span></code> loop handling for so long because to test it we first need the assignment to work. We can now also implement a version of the <code>factorial</code> function using the <code class="sourceCode javascript"><span class="cf">while</span></code> loop:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">factorial</span>(n) {</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> result <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (n <span class="op">!=</span> <span class="dv">1</span>) {</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> result <span class="op">*</span> n<span class="op">;</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<blockquote>
<p><strong>Explore</strong></p>
<p>How do you implement a <code class="sourceCode javascript"><span class="cf">for</span></code> loop? A <code class="sourceCode javascript"><span class="cf">for</span></code> loop can be thought of as a special case of the <code class="sourceCode javascript"><span class="cf">while</span></code> loop. Consider that the following <code class="sourceCode javascript"><span class="cf">for</span></code> loop:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span>) {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">body</span>()<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Is equivalent to this <code class="sourceCode javascript"><span class="cf">while</span></code> loop:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (i <span class="op">&lt;</span> <span class="dv">5</span>) {</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">body</span>()<span class="op">;</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</blockquote>
<hr />
<p>The baseline compiler is done. Now, onto <em>Part II</em>, where we will continue extending and expanding the compiler with new functionality.</p>
<center><a href="./09-introduction-to-part-2">Next: Chapter 9. Introduction to Part II</a></center>


  <hr class="fleuron" />
</body>
</html>
