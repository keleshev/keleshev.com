<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=750;" />
  <!-- favicon stuff -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
  <!--link rel="mask-icon" href="/safari-pinned-tab.svg?v=1"> <!-- color="#5bbad5">-->
  <link rel="shortcut icon" href="/favicon.ico?v=1">
  <!--meta name="theme-color" content="#ffffff"-->

  <title>9. Introduction to Part II • Compiling to Assembly from Scratch</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
  <span id="home-menu"><a title="Home" href="/">☰</a></span>





<header id="title-block-header">
</header>
<h1>Compiling to Assembly<small><small><br/>from Scratch</small></small><br/></h1>
<center><p> — <a href='./#table-of-contents'>Table of Contents</a> — </p></center>
<span id="fold"> </span>
<h1><br/><small><small>Chapter 9</small></small><br/>Introduction to Part II<br/><br/></h1>
<p> </p>
<p>Before extending the compiler, let’s discuss the language we have implemented so far.</p>
<p>Is our language memory-safe? What is memory safety, anyway? Simply speaking, a language is memory-safe if it does not allow you to write a program that causes a segmentation fault. The baseline language is memory-safe if we limit ourselves to calling functions that we have defined ourselves. However, our calling convention allows us to call arbitrary <code>libc</code> functions. You can find creative ways to call these functions that will lead to a segmentation fault (try <code>free(42)</code>). So, unless we do something about that, the baseline language is not memory-safe.</p>
<p>A way to fix that is to introduce a prefix for function labels. For example, a function <code>factorial</code> can be compiled with a label <code>ts$factorial:</code>, and a call to <code>factorial</code> can be compiled to a jump to <code>ts$factorial</code>. This way, you can only call functions that are defined in the source language, or that had explicit wrappers written in assembly. These wrappers can be auto-generated by the compiler and also handle type conversion, if necessary.</p>
<p>Is our language dynamically-typed? Or is it statically-typed? Both and neither! The baseline language supports only integer numbers. So, it could be thought of as a dynamically-typed language with only one data type, or as a statically-typed language with one static type. But we are soon to change this.</p>
<p>However, before we explore static and dynamic typing, we need to have more than one data type in our language. We will start by introducing booleans, undefined, and then arrays. First, we will introduce them in an unsafe/untyped manner, and then we will apply static/dynamic treatment to them.</p>
<center><a href="./10-primitive-scalar-data-types#fold">Next: Chapter 10. Primitive Scalar Data Types</a></center>


  <hr class="fleuron" />
</body>
</html>
